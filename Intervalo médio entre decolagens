# -*- coding: utf-8 -*-
"""
Intervalo médio entre decolagens (coluna 'Decolagem')
Arquivo único: C:\Python\SBSP_2025_01_01_A_2025_08_12.xlsx

- Considera apenas dias úteis (seg–sex)
- Um gráfico por mês: intervalo médio por hora (0–23)
- Topo do gráfico com folga automática para não cortar rótulos
"""

from pathlib import Path
import unicodedata
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# ===================== CONFIG =====================
ARQUIVO = Path(r"C:\Python\SBSP_2025_01_01_A_2025_08_12.xlsx")
COL_DECOLAGEM_ALVO = "Decolagem"
MOSTRAR_GRAFICOS = True
DESCARTAR_INTERVALOS_NEGATIVOS = True
DESCARTAR_INTERVALOS_MUITO_GRANDES = True
LIMITE_MINUTOS_MAX = 360
HEADROOM_PERC = 0.15     # folga no topo do eixo Y (15%)
# ===================================================

plt.ion()  # gráficos não bloqueantes

def _norm(s: str) -> str:
    s = unicodedata.normalize("NFKD", str(s))
    s = "".join(ch for ch in s if not unicodedata.combining(ch))
    return s.strip().lower()

def localizar_coluna_decolagem(cols) -> str | None:
    alvo = _norm(COL_DECOLAGEM_ALVO)
    mapa = {c: _norm(c) for c in cols}
    for original, norm in mapa.items():
        if norm == alvo:
            return original
    candidatos = {"decolagem", "offblock", "off-block", "off_block", "saida"}
    for original, norm in mapa.items():
        if norm in candidatos:
            return original
    return None

def ler_arquivo(p: Path) -> pd.DataFrame:
    if not p.exists():
        raise FileNotFoundError(f"Arquivo não encontrado: {p}")
    suf = p.suffix.lower()
    if suf == ".xlsx":
        return pd.read_excel(p, engine="openpyxl")
    if suf == ".csv":
        for enc in ("utf-8", "latin1"):
            try:
                return pd.read_csv(p, encoding=enc)
            except Exception:
                pass
        raise RuntimeError(f"Falha ao ler CSV {p.name}.")
    if suf == ".parquet":
        return pd.read_parquet(p)
    raise ValueError(f"Extensão não suportada: {suf}")

def calcular_base(df: pd.DataFrame, col_dec: str) -> pd.DataFrame:
    serie_dt = pd.to_datetime(df[col_dec], errors="coerce", dayfirst=True, infer_datetime_format=True)
    base = (
        pd.DataFrame({"decolagem": serie_dt})
        .dropna()
        .sort_values("decolagem")
        .reset_index(drop=True)
    )
    base["delta_s"] = base["decolagem"].diff().dt.total_seconds()
    if DESCARTAR_INTERVALOS_NEGATIVOS:
        base.loc[base["delta_s"] <= 0, "delta_s"] = np.nan
    if DESCARTAR_INTERVALOS_MUITO_GRANDES:
        base.loc[(base["delta_s"] / 60.0) > LIMITE_MINUTOS_MAX, "delta_s"] = np.nan
    base["hora"] = base["decolagem"].dt.hour
    base["weekday"] = base["decolagem"].dt.weekday
    base["ano_mes"] = base["decolagem"].dt.to_period("M").astype(str)
    return base

def somente_dias_uteis(base: pd.DataFrame) -> pd.DataFrame:
    return base[base["weekday"] < 5].copy()

def medias_por_hora_e_mes(base_uteis: pd.DataFrame):
    media_global_min = (base_uteis["delta_s"].dropna().mean() or np.nan) / 60.0
    por_hora = (
        base_uteis.dropna(subset=["delta_s"])
        .groupby("hora", as_index=False)["delta_s"]
        .mean()
        .rename(columns={"delta_s": "media_min"})
        .sort_values("hora")
        .reset_index(drop=True)
    )
    por_hora["media_min"] = por_hora["media_min"] / 60.0
    por_mes_hora = (
        base_uteis.dropna(subset=["delta_s"])
        .groupby(["ano_mes", "hora"], as_index=False)["delta_s"]
        .mean()
        .rename(columns={"delta_s": "media_min"})
        .sort_values(["ano_mes", "hora"])
        .reset_index(drop=True)
    )
    por_mes_hora["media_min"] = por_mes_hora["media_min"] / 60.0
    return media_global_min, por_hora, por_mes_hora

def plotar_um_grafico_mes(df_mes: pd.DataFrame, ano_mes: str):
    fig, ax = plt.subplots(figsize=(9, 4))
    ax.bar(df_mes["hora"], df_mes["media_min"])

    # --- folga automática no topo para não cortar rótulos ---
    ymax = (df_mes["media_min"].max() or 0) * (1 + HEADROOM_PERC)
    if ymax <= 0:  # evita ylim(0,0)
        ymax = 1
    ax.set_ylim(0, ymax)

    ax.set_title(f"Intervalo médio entre decolagens por hora (min) – {ano_mes} – Dias úteis")
    ax.set_xlabel("Hora do dia")
    ax.set_ylabel("Média do intervalo (min)")
    ax.set_xticks(range(0, 24))

    # Rótulos com clip desligado para nunca cortar
    for x, y in zip(df_mes["hora"], df_mes["media_min"]):
        ax.annotate(f"{y:.1f}", (x, y), ha="center", va="bottom",
                    xytext=(0, 3), textcoords="offset points",
                    fontsize=9, clip_on=False)

    ax.margins(x=0.02)  # um pouco de margem lateral
    ax.grid(axis="y", linestyle="--", alpha=0.5)
    plt.tight_layout()
    plt.show(block=False); plt.pause(0.05)

def main():
    print("\n=== Início ===\n", flush=True)
    df = ler_arquivo(ARQUIVO)
    print(f"Arquivo carregado com {len(df):,} linhas e {len(df.columns)} colunas."
          .replace(",", "."), flush=True)

    col_dec = localizar_coluna_decolagem(df.columns)
    if col_dec is None:
        raise ValueError("Coluna 'Decolagem' não encontrada no arquivo.")
    print(f"Usando a coluna de data-hora: '{col_dec}'", flush=True)

    base = calcular_base(df, col_dec)
    base_uteis = somente_dias_uteis(base)

    media_global_min, por_hora, por_mes_hora = medias_por_hora_e_mes(base_uteis)

    print("\n--- Intervalo médio global (dias úteis) ---")
    if pd.isna(media_global_min):
        print("Não foi possível calcular (dados insuficientes).")
    else:
        print(f"{media_global_min:.2f} minutos")

    print("\n--- Intervalo médio por hora (dias úteis) ---")
    if por_hora.empty:
        print("Sem intervalos válidos.")
    else:
        print(
            por_hora.to_string(
                index=False,
                formatters={"media_min": lambda v: f"{v:.2f}"}
            )
        )

    print("\n--- Meses disponíveis ---")
    meses = por_mes_hora["ano_mes"].unique().tolist()
    print(meses)

    if MOSTRAR_GRAFICOS:
        for am in meses:
            df_mes = por_mes_hora[por_mes_hora["ano_mes"] == am]
            plotar_um_grafico_mes(df_mes, am)

    print("\n=== Fim ===\n", flush=True)
    plt.pause(0.1)

if __name__ == "__main__":
    main()
