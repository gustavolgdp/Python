import re
from datetime import datetime, timedelta
import pandas as pd
import matplotlib.pyplot as plt
from tqdm import tqdm

# =========================
# Configura√ß√µes iniciais
# =========================
# Caminho do arquivo (AJUSTADO: agora em C:\BD\)
file_path = r"C:\BD\Conversa do WhatsApp com Escala APP-SP  FMC-SP  TWR-SP.txt"

# Regex
linha_completa_regex = re.compile(
    r'\b(1S|2S|3S)\s+([\w\s\.\-√Å-√ö√°-√∫√ß√á]+?)\s*[:\-‚Äì]?\s*(\d+)\s+dia[s]?\b',
    re.IGNORECASE
)
data_regex = re.compile(r'^(\d{2}/\d{2}/\d{4}) \d{2}:\d{2} -')

# =========================
# Leitura do arquivo
# =========================
with open(file_path, encoding='utf-8') as f:
    lines = f.readlines()

# =========================
# Processamento dos registros
# =========================
registros = []

print("üîç Processando dispensas por pessoa...")
for line in tqdm(lines, desc="Analisando linhas"):
    data_match = data_regex.search(line)
    match = linha_completa_regex.search(line)
    if data_match and match:
        data_str = data_match.group(1)
        try:
            data = datetime.strptime(data_str, "%d/%m/%Y")
            graduacao = match.group(1).upper()
            nome = match.group(2).strip().title()
            dias = int(match.group(3))
            identificador = f"{graduacao} {nome}"

            # Excluir 1S Solange
            if identificador.lower() == "1s solange":
                continue

            registros.append((data, identificador, dias))
        except ValueError:
            # Linhas que n√£o batem com a data dd/mm/aaaa ou outra falha
            continue

# =========================
# DataFrame base
# =========================
df = pd.DataFrame(registros, columns=["data", "pessoa", "dias"])
if df.empty:
    raise SystemExit("Nenhuma dispensa encontrada com o padr√£o especificado.")

# Per√≠odos derivados
df["semana"] = df["data"].dt.to_period("W").apply(lambda r: r.start_time)
df["mes"]    = df["data"].dt.to_period("M").apply(lambda r: r.start_time)

# =========================
# Agrupamentos tradicionais
# =========================
por_pessoa = df.groupby("pessoa")["dias"].sum().sort_values(ascending=True)
por_semana = df.groupby("semana")["dias"].sum().reset_index()
por_mes    = df.groupby("mes")["dias"].sum().reset_index()
media_semana = por_semana["dias"].mean()
media_mes    = por_mes["dias"].mean()

# =========================
# GR√ÅFICOS tradicionais
# =========================
# Gr√°fico por pessoa (horizontal)
plt.figure(figsize=(10, max(6, len(por_pessoa) * 0.3)))
bars = plt.barh(por_pessoa.index, por_pessoa.values)
for bar in bars:
    largura = bar.get_width()
    plt.text(largura + 0.5, bar.get_y() + bar.get_height() / 2,
             f'{int(largura)}', va='center', fontsize=9)
plt.title("Total de Dias de Dispensa M√©dica por Pessoa (exceto 1S Solange)")
plt.xlabel("Dias de Dispensa")
plt.ylabel("Pessoa")
plt.tight_layout()
plt.grid(axis='x', linestyle='--', alpha=0.6)
plt.show()

# Gr√°fico por semana (linha + √°rea)
plt.figure(figsize=(12, 5))
plt.plot(por_semana["semana"], por_semana["dias"], marker='o')
plt.fill_between(por_semana["semana"], por_semana["dias"])
plt.title("Dias de Dispensa M√©dica por Semana")
plt.xlabel("Semana")
plt.ylabel("Total de Dias")
plt.xticks(rotation=45)
plt.grid(True)
plt.tight_layout()
plt.show()

# Gr√°fico por m√™s (linha + √°rea)
plt.figure(figsize=(10, 5))
plt.plot(por_mes["mes"], por_mes["dias"], marker='o')
plt.fill_between(por_mes["mes"], por_mes["dias"])
plt.title("Dias de Dispensa M√©dica por M√™s")
plt.xlabel("M√™s")
plt.ylabel("Total de Dias")
plt.xticks(rotation=45)
plt.grid(True)
plt.tight_layout()
plt.show()

# =========================
# NOVO: S√©rie temporal de DISPENSAS ATIVAS por dia
# (sobreposi√ß√£o por dura√ß√£o)
# =========================
# Para cada dispensa, consideramos:
# - in√≠cio = df['data']
# - fim    = df['data'] + (df['dias'] - 1) dias
# Em seguida, criamos um "delta" com +1 em cada in√≠cio e -1 em (fim + 1 dia).
# O cumsum desses deltas ao longo do tempo d√° a contagem de dispensas ativas por dia.

df["inicio"] = df["data"]
df["fim"]    = df["data"] + pd.to_timedelta(df["dias"] - 1, unit="D")

# Criar s√©ries de deltas
print("‚è±Ô∏è Calculando sobreposi√ß√£o por dura√ß√£o (linha de varredura)...")
# Como podemos ter datas repetidas, agregamos por data
start_increments = df.groupby("inicio").size().rename("start_inc")
end_decrements   = df.groupby(df["fim"] + pd.Timedelta(days=1)).size().rename("end_dec") * -1

# Combina os deltas e ordena
deltas = pd.concat([start_increments, end_decrements], axis=1).fillna(0)
deltas["delta"] = deltas["start_inc"] + deltas["end_dec"]
deltas = deltas["delta"].sort_index()

# Gera o √≠ndice di√°rio completo entre o primeiro in√≠cio e o √∫ltimo fim
idx_full = pd.date_range(start=df["inicio"].min(),
                         end=df["fim"].max(), freq="D")

# Reindexa, preenche faltantes com 0, e aplica cumsum para obter as ativas
deltas_full = deltas.reindex(idx_full, fill_value=0)
ativas_por_dia = deltas_full.cumsum().rename("dispensas_ativas")

# Opcional: m√©dia m√≥vel (suaviza√ß√£o)
rolling_7d = ativas_por_dia.rolling(window=7, min_periods=1).mean()

# Gr√°fico da s√©rie di√°ria de dispensas ativas
plt.figure(figsize=(12, 5))
plt.plot(ativas_por_dia.index, ativas_por_dia.values, label="Ativas por dia")
plt.plot(rolling_7d.index, rolling_7d.values, linestyle="--", label="M√©dia m√≥vel 7d")
plt.fill_between(ativas_por_dia.index, ativas_por_dia.values, alpha=0.3)
plt.title("Dispensas M√©dicas Ativas por Dia (sobreposi√ß√£o por dura√ß√£o)")
plt.xlabel("Data")
plt.ylabel("Quantidade de dispensas ativas")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# =========================
# Sa√≠das textuais
# =========================
print("\n=== Dias de Dispensa por Semana ===")
print(por_semana.to_string(index=False))

print("\n=== Dias de Dispensa por M√™s ===")
print(por_mes.to_string(index=False))

print(f"\nM√©dia semanal: {media_semana:.2f} dias")
print(f"M√©dia mensal: {media_mes:.2f} dias")
