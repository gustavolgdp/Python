# -*- coding: utf-8 -*-
r"""
Dimensionamento ÓTIMO (ILP) com Polars + PuLP + HEATMAP em console.

- Agrega demanda em slots [s, s+30) alinhados em :15/:45 com group_by_dynamic(offset="15m").
- Resolve ILP por turno (M/T/P) e salva Excel.
- Ao final, imprime:
    1) As 20 primeiras linhas da tabela resultado
    2) Um "heatmap" ASCII (datas x [M,T,P]) com ANSI 256 cores

Requisitos:
    pip install polars pulp openpyxl tqdm colorama
"""

import os, sys, math, datetime as dt
from typing import List
from tqdm import tqdm

PARQUET_FATO = r"C:\Output\parquet\fato_setorizacao_30min.parquet"
OUT_XLSX     = r"C:\Output\dimensionamento_turnos_ATCO_otimizado.xlsx"

WEEKDAY_ABBR = {0:"SEG", 1:"TER", 2:"QUA", 3:"QUI", 4:"SEX", 5:"SAB", 6:"DOM"}
TURNO_ORDER  = {"M":1, "T":2, "P":3}

# Pernoite FIXO (21–22, 22–23, 23–00, 00–01, 01–02, 02–03, 03–04, 04–05, 05–06)
PERN_WEEKDAY = [14, 14, 3, 3, 2, 2, 2, 6, 8]   # Seg–Sex
PERN_SAT     = [11,  7, 4, 3, 2, 2, 2, 4, 4]   # Sábado
PERN_SUN     = [20, 13, 4, 3, 2, 2, 2, 5, 7]   # Domingo

def pernoite_vector_for_day(d: dt.date):
    wd = d.weekday()
    hours = PERN_SAT if wd == 5 else (PERN_SUN if wd == 6 else PERN_WEEKDAY)
    vec18 = [v for v in hours for _ in (0,1)]
    return vec18[1:18]  # 17 slots (descarta 21:15–21:45)

def week_index_from_year_start(date_obj: dt.date) -> int:
    jan1 = dt.date(date_obj.year, 1, 1)
    return 1 + (date_obj - jan1).days // 7

def make_data_relativa_base(date_obj: dt.date) -> str:
    n = week_index_from_year_start(date_obj)
    ddd = WEEKDAY_ABBR[date_obj.weekday()]
    return f"{n}{ddd}"

def turno_windows_for_day(d: dt.date):
    y,m,day = d.year, d.month, d.day
    manha_ini = dt.datetime(y,m,day,5,45)
    manha_fim = dt.datetime(y,m,day,13,45)
    tarde_ini = dt.datetime(y,m,day,13,45)
    tarde_fim = dt.datetime(y,m,day,21,15)
    perno_ini = dt.datetime(y,m,day,21,15)
    perno_fim = (dt.datetime(y,m,day) + dt.timedelta(days=1)).replace(hour=5, minute=45)
    return (manha_ini, manha_fim), (tarde_ini, tarde_fim), (perno_ini, perno_fim)

def slots_between(start: dt.datetime, end: dt.datetime) -> List[dt.datetime]:
    out, cur = [], start
    step = dt.timedelta(minutes=30)
    while cur < end:
        out.append(cur)
        cur += step
    return out

# --- libs ---
try:
    import polars as pl
except Exception as e:
    sys.exit(f"Instale 'polars': {e}")

try:
    import openpyxl  # noqa
except Exception as e:
    sys.exit(f"Instale 'openpyxl': {e}")

try:
    import pulp
    from pulp import LpProblem, LpMinimize, LpVariable, lpSum, LpInteger, value
    from pulp import PULP_CBC_CMD, GLPK_CMD, HiGHS_CMD
except Exception as e:
    sys.exit(f"Instale 'pulp': {e}")

# Para o heatmap (cores ANSI)
try:
    from colorama import init as colorama_init
    colorama_init()
    ANSI_OK = True
except Exception:
    ANSI_OK = False

# --- solver ---
def pick_solver():
    try: return PULP_CBC_CMD(msg=False)
    except Exception: pass
    try: return HiGHS_CMD(msg=False)
    except Exception: pass
    try: return GLPK_CMD(msg=False)
    except Exception: pass
    return None

SOLVER = pick_solver()

# --- padrões factíveis ---
def generate_patterns(num_slots: int, min_on: int, max_on: int):
    ON_LENGTHS = [2,3,4]  # 1h, 1h30, 2h
    MIN_GAP    = 2        # 1h folga
    MAX_BLOCKS = 3
    patterns = set()

    def place_block(start_idx, blocks_used, cur):
        if blocks_used > MAX_BLOCKS: return
        if sum(cur) > max_on:        return
        total_on = sum(cur)
        if blocks_used >= 1 and (min_on <= total_on <= max_on):
            patterns.add(tuple(cur))
        if start_idx >= num_slots: return
        i = start_idx
        while i < num_slots:
            for L in ON_LENGTHS:
                end = i + L
                if end > num_slots: continue
                if any(cur[j]==1 for j in range(i,end)): continue
                saved = cur[i:end]
                for j in range(i,end): cur[j]=1
                next_start = end + MIN_GAP
                place_block(next_start, blocks_used+1, cur)
                cur[i:end] = saved
            i += 1

    place_block(0, 0, [0]*num_slots)
    if not patterns:
        base = [0]*num_slots
        for s in range(0, num_slots-3):
            p = base.copy()
            for k in range(s, s+4): p[k]=1
            patterns.add(tuple(p))
    return [list(p) for p in patterns]

def solve_turn_demand(demand_slots, min_on, max_on):
    demand_slots = [int(x) if (x is not None) and (x >= 0) else 0 for x in demand_slots]
    N = len(demand_slots)
    pats = generate_patterns(N, min_on, max_on)

    model = LpProblem("CoberturaTurno", LpMinimize)
    x = [LpVariable(f"x_{i}", lowBound=0, cat=LpInteger) for i in range(len(pats))]
    model += lpSum(x)
    for t in range(N):
        model += lpSum(x[i] * pats[i][t] for i in range(len(pats))) >= demand_slots[t]

    if SOLVER is not None: model.solve(SOLVER)
    else:                   model.solve()

    status = pulp.LpStatus[model.status]
    if status not in ("Optimal","Feasible"):
        raise RuntimeError(f"Solver status: {status}")
    return int(sum(int(value(var)) for var in x))

# ---- Leitura/Agregação com Polars ----
if not os.path.isfile(PARQUET_FATO):
    sys.exit(f"Parquet não encontrado: {PARQUET_FATO}")

tqdm.write("Lendo Parquet com Polars...")
df = pl.read_parquet(PARQUET_FATO)

need = {"ts","Q_CTR","Q_ASS","Q_COOR"}
missing = need - set(df.columns)
if missing:
    sys.exit(f"Colunas ausentes: {sorted(missing)}")

# ts -> Datetime (robusto)
ts_dtype = df.schema["ts"]
if ts_dtype == pl.Utf8:
    try:
        df = df.with_columns(pl.col("ts").str.strptime(pl.Datetime, strict=False).alias("ts"))
    except Exception:
        df = df.with_columns(pl.col("ts").str.to_datetime(strict=False).alias("ts"))
elif ts_dtype != pl.Datetime:
    df = df.with_columns(pl.col("ts").cast(pl.Datetime).alias("ts"))

df = df.drop_nulls(subset=["ts"])

# Q_ATCO
df = df.with_columns(
    (pl.col("Q_CTR").fill_null(0).cast(pl.Int64) +
     pl.col("Q_ASS").fill_null(0).cast(pl.Int64) +
     pl.col("Q_COOR").fill_null(0).cast(pl.Int64)).alias("Q_ATCO")
)

# Agregação em janelas [s, s+30) com chave no INÍCIO do slot, alinhadas em :15 e :45
demanda = (df
    .group_by_dynamic(
        index_column="ts",
        every="30m",
        period="30m",
        offset="15m",  # produz slots 05:45, 13:45, 21:15 etc.
        label="left"
    )
    .agg(pl.max("Q_ATCO").alias("demanda"))
    .sort("ts")
    .rename({"ts":"slot_start"})
)

min_day = demanda["slot_start"].min().date()
max_day = demanda["slot_start"].max().date()
slot_map = dict(zip(demanda["slot_start"], demanda["demanda"]))

# ---- Loop de dias ----
rows = []
current = min_day
while current <= max_day:
    d = current
    (mi, mf), (ti, tf), _ = turno_windows_for_day(d)
    slots_m = slots_between(mi, mf)
    slots_t = slots_between(ti, tf)

    dem_m = [slot_map.get(s, 0) for s in slots_m]
    dem_t = [slot_map.get(s, 0) for s in slots_t]
    dem_p = pernoite_vector_for_day(d)

    qtd_m = solve_turn_demand(dem_m, min_on=8, max_on=11); tqdm.write(f"{d} Manhã OK")
    qtd_t = solve_turn_demand(dem_t, min_on=8, max_on=11); tqdm.write(f"{d} Tarde OK")
    qtd_p = solve_turn_demand(dem_p, min_on=6, max_on=9);  tqdm.write(f"{d} Pernoite OK")

    base = make_data_relativa_base(d)
    rows.append((base + "M", d, qtd_m))
    rows.append((base + "T", d, qtd_t))
    rows.append((base + "P", d, qtd_p))

    current += dt.timedelta(days=1)

# ---- Monta DataFrame e salva Excel ----
out = pl.DataFrame(rows, schema=["DATA_RELATIVA","DATA_CIVIL","Quantidade"]).with_columns([
    pl.col("DATA_RELATIVA").str.slice(-1,1).alias("__turno_letter")
]).with_columns([
    pl.when(pl.col("__turno_letter")=="M").then(1)
     .when(pl.col("__turno_letter")=="T").then(2)
     .otherwise(3).alias("__tur_ord__")
]).sort(["DATA_CIVIL","__tur_ord__"]).drop(["__turno_letter","__tur_ord__"])

# 1) Mostra 20 primeiras linhas
import pandas as pd
tqdm.write("Amostra (20 primeiras linhas):")
tqdm.write(out.head(20).to_pandas().to_string(index=False))

# 2) HEATMAP ASCII (datas x [M,T,P])
def print_heatmap_console(df_pl: pl.DataFrame, max_days: int = 90):
    """
    Imprime um heatmap ASCII:
      linhas = datas
      colunas = M T P
      célula = quantidade (cor de fundo proporcional)
    Mostra no máx. 'max_days' últimas datas para não explodir o console.
    """
    pdf = df_pl.to_pandas()
    # pivot: index=data, columns=turno(M/T/P), values=qtd
    pdf["TURNO"] = pdf["DATA_RELATIVA"].str[-1]
    piv = (pdf.pivot(index="DATA_CIVIL", columns="TURNO", values="Quantidade")
               .reindex(columns=["M","T","P"]))
    piv = piv.sort_index()

    # Limita nº de linhas no console
    if len(piv) > max_days:
        piv = piv.iloc[-max_days:]
        tqdm.write(f"(Heatmap exibindo apenas as últimas {max_days} datas para caber no console)")

    # Escala de cores
    vmin = int(pd.to_numeric(piv.stack(), errors="coerce").min(skipna=True) or 0)
    vmax = int(pd.to_numeric(piv.stack(), errors="coerce").max(skipna=True) or 0)
    if vmax <= vmin: vmax = vmin + 1  # evita divisão por zero

    def cell(val):
        if pd.isna(val):
            return "  .. "  # sem dado
        val = int(val)
        # normaliza 0..1
        x = (val - vmin) / (vmax - vmin)
        # cor de fundo 232..255 (escala de cinza); 232 é escuro, 255 é claro
        bg = int(232 + round(x * 23))
        # cor do texto: preto se fundo claro, branco se fundo escuro
        fg = 16 if bg >= 244 else 231
        text = f"{val:>3d} "
        if ANSI_OK and sys.stdout.isatty():
            return f"\x1b[48;5;{bg}m\x1b[38;5;{fg}m{text}\x1b[0m"
        else:
            # fallback sem cor
            return f"{text}"

    # Cabeçalho
    header = "Data       |  M    T    P"
    sep = "-" * len(header)
    tqdm.write(header)
    tqdm.write(sep)
    for idx, row in piv.iterrows():
        dstr = pd.to_datetime(idx).strftime("%Y-%m-%d")
        m,t,p = cell(row.get("M")), cell(row.get("T")), cell(row.get("P"))
        tqdm.write(f"{dstr} | {m}{t}{p}")

# imprime heatmap no console
print_heatmap_console(out, max_days=90)

# Salvar Excel
os.makedirs(os.path.dirname(OUT_XLSX), exist_ok=True)
with pd.ExcelWriter(OUT_XLSX, engine="openpyxl") as w:
    out.to_pandas().to_excel(w, sheet_name="Dimensionamento_ILP", index=False)

tqdm.write(f"Excel salvo em: {OUT_XLSX}")
